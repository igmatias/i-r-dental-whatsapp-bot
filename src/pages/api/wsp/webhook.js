// ==============================================
// File: src/pages/api/wsp/webhook.js
// Purpose: WhatsApp webhook + Operator feed (GET) + Operator SEND (POST)
// Notes:
//  - Redis sessions (Upstash) + FLOW_* logs de diagn√≥stico
//  - Bienvenida SIEMPRE con botones (men√∫ 1/2 y 2/2)
//  - Men√∫s: Sedes / Estudios / Obras / Env√≠o / Subir orden / Operador
//  - Flujo "Env√≠o de estudio" con pasos y botones (sede / v√≠a / confirmar)
//  - Persistencia para consola: lpush chat:..., zadd chats:index
//  - Upstash v1 compat: zrange({rev:true, withScores:true}) + polyfill zrevrange
//  - Env√≠o AR sin ‚Äú9‚Äù: normalizamos a 54‚Ä¶ (E.164 sin '+')
// ==============================================

import { Redis } from '@upstash/redis'

export const config = { api: { bodyParser: false } }

// --- ENV ---
const {
  OPERATOR_SECRET = 'irdental2025',
  WHATSAPP_PHONE_ID,
  WHATSAPP_TOKEN,
  WSP_VERIFY_TOKEN,
  UPSTASH_REDIS_REST_URL,
  UPSTASH_REDIS_REST_TOKEN,
  TEST_RECIPIENT_FORMAT = 'no9', // 'no9' (mantener sin 9) | 'with9' | ''
} = process.env

const redis = new Redis({ url: UPSTASH_REDIS_REST_URL, token: UPSTASH_REDIS_REST_TOKEN })

// Compat: si no existe zrevrange, emulamos con zrange rev:true
if (typeof redis.zrevrange !== 'function') {
  redis.zrevrange = async (key, start, stop, opts = {}) => {
    return await redis.zrange(key, start, stop, { ...opts, rev: true })
  }
}

// --- Keys Redis ---
const kSess   = (wa) => `sess:${wa}`
const kMsgs   = (wa) => `chat:${wa}:messages`
const kSeen   = (wa) => `seen:${wa}`
const kChats  = 'chats:index'
const kWaRaw  = (wa) => `waid:${wa}` // √∫ltimo wa_id (crudo) visto

// --- LOG helper ---
function flowLog(tag, obj) {
  console.log(`FLOW_${tag} ‚Üí`, typeof obj === 'string' ? obj : JSON.stringify(obj))
}

// --- HTTP body reader (raw JSON) ---
async function readBody(req) {
  const chunks = []
  for await (const chunk of req) chunks.push(chunk)
  const raw = Buffer.concat(chunks).toString('utf8') || '{}'
  try { return { raw, json: JSON.parse(raw) } } catch { return { raw, json: {} } }
}

// --- Normalizaci√≥n de n√∫meros ---
function normalizeWaKey(waId) {
  // Guardamos claves con "+54..." (para UI), pero enviamos a Meta sin "+"
  let id = waId || ''
  if (!id) return null
  if (!id.startsWith('+')) id = '+' + id
  if (TEST_RECIPIENT_FORMAT === 'with9') id = id.replace(/^\+54(?!9)/, '+549')
  if (TEST_RECIPIENT_FORMAT === 'no9')   id = id.replace(/^\+549/, '+54')
  return id
}

// Sanitiza para enviar a Meta: solo d√≠gitos y SIN ‚Äú9‚Äù intermedio para AR
function sanitizeToE164NoPlus(toRawDigits) {
  let to = String(toRawDigits || '').replace(/\D/g, '')
  if (to.startsWith('549')) to = '54' + to.slice(3) // quitar 9
  return to // Meta quiere sin '+'
}

// --- Sesiones JSON-safe ---
async function getSession(waKey) {
  const raw = await redis.get(kSess(waKey))
  try { return raw ? JSON.parse(raw) : { state: 'idle', step: 0 } }
  catch { return { state: 'idle', step: 0 } }
}
async function setSession(waKey, sess) {
  return await redis.set(kSess(waKey), JSON.stringify(sess))
}

// --- Persistencia consola ---
async function appendMessage(waKey, msg) {
  await redis.lpush(kMsgs(waKey), JSON.stringify(msg))
  await redis.ltrim(kMsgs(waKey), 0, 499)
  await redis.zadd(kChats, { score: msg.ts || Date.now(), member: waKey })
}
async function getHistory(waKey, limit = 100) {
  const arr = await redis.lrange(kMsgs(waKey), 0, limit - 1)
  const out = arr.map(s => { try { return JSON.parse(s) } catch { return null } }).filter(Boolean)
  return out.sort((a,b) => (a.ts||0)-(b.ts||0))
}
async function alreadyProcessed(waKey, messageId) {
  const last = await redis.get(kSeen(waKey))
  if (last === messageId) return true
  await redis.set(kSeen(waKey), messageId)
  return false
}

// --- Env√≠os ---
async function sendJson(toRawDigits, payload, storeKey, label='SEND_JSON') {
  if (!WHATSAPP_TOKEN || !WHATSAPP_PHONE_ID) {
    flowLog('SEND_GUARD', { error: 'Missing WhatsApp env', WHATSAPP_PHONE_ID: !!WHATSAPP_PHONE_ID, WHATSAPP_TOKEN: !!WHATSAPP_TOKEN })
    return { ok:false, status:500, data:{ error:'Missing env' } }
  }
  let to = sanitizeToE164NoPlus(toRawDigits)
  flowLog(`${label}_REQ`, { to, type: payload.type || 'text' })
  const url = `https://graph.facebook.com/v20.0/${WHATSAPP_PHONE_ID}/messages`
  const res = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type':'application/json', Authorization:`Bearer ${WHATSAPP_TOKEN}` },
    body: JSON.stringify({ messaging_product:'whatsapp', to, ...payload })
  })
  let data = {}
  try { data = await res.json() } catch {}
  flowLog(`${label}_RES`, { status: res.status, data })
  try {
    const outId = data?.messages?.[0]?.id || `out-${Date.now()}`
    // Persistimos una representaci√≥n legible para consola
    const snapshot = {
      id: outId,
      from: storeKey,
      direction: 'out',
      ts: Date.now(),
    }
    if (payload.type === 'text') snapshot.text = payload.text?.body || ''
    if (payload.type === 'interactive') {
      const i = payload.interactive || {}
      snapshot.text = (i.body?.text) || ''
      if (i.type === 'button') {
        snapshot.buttons = (i.action?.buttons || []).map(b => b?.reply?.title).filter(Boolean)
      }
      if (i.type === 'list') {
        // Mostrar t√≠tulos de items de lista como ‚Äúchips‚Äù
        const items = []
        for (const sec of i.action?.sections || []) {
          for (const it of sec?.rows || []) items.push(it?.title)
        }
        snapshot.buttons = items
      }
    }
    await appendMessage(storeKey, snapshot)
  } catch {}
  return { ok: res.ok, status: res.status, data }
}

async function sendText(toRawDigits, body, storeKey) {
  return sendJson(toRawDigits, { type:'text', text:{ body } }, storeKey, 'SEND_TEXT')
}

async function sendButtons(toRawDigits, body, buttons, storeKey) {
  // M√°x 3 botones
  const payload = {
    type: 'interactive',
    interactive: {
      type: 'button',
      body: { text: body || '' },
      action: { buttons: buttons.slice(0,3).map((b,i) => ({ type:'reply', reply:{ id: b.id || `btn_${i}`, title: b.title || `Opci√≥n ${i+1}` } })) }
    }
  }
  return sendJson(toRawDigits, payload, storeKey, 'SEND_BUTTONS')
}

async function sendList(toRawDigits, body, sections, storeKey) {
  const payload = {
    type: 'interactive',
    interactive: {
      type: 'list',
      body: { text: body || '' },
      action: { button: 'Ver opciones', sections }
    }
  }
  return sendJson(toRawDigits, payload, storeKey, 'SEND_LIST')
}

// --- Textos base / data (tomados de tu webhook anterior) ---
const HOURS = `üïí Horarios (todas las sedes)
‚Ä¢ Lunes a viernes: 09:00 a 17:30
‚Ä¢ S√°bados: 09:00 a 12:30`
const NO_TURNO = `üìå Atenci√≥n SIN TURNO, por orden de llegada.`

// Links sedes (ajust√° si cambian)
const LINKS = {
  QUILMES: 'https://maps.google.com/?q=i-R+Dental+Quilmes',
  AVELL:   'https://maps.google.com/?q=i-R+Dental+Avellaneda',
  LOMAS:   'https://maps.google.com/?q=i-R+Dental+Lomas',
}

const SEDES = {
  QUILMES: { title:'Sede Quilmes ‚Äî i-R Dental',   dir:'Moreno 851 ‚Äî 1¬∞ B', tel:'4257-3638', mail:'quilmes@irdental.com.ar', link: LINKS.QUILMES },
  AVELL:   { title:'Sede Avellaneda ‚Äî i-R Dental', dir:'9 de Julio 64 ‚Äî 2¬∞ A', tel:'4222-5553', mail:'avellaneda@irdental.com.ar', link: LINKS.AVELL },
  LOMAS:   { title:'Sede Lomas de Zamora ‚Äî i-R Dental', dir:'Espa√±a 156 ‚Äî PB', tel:'4244-0148', mail:'lomas@irdental.com.ar', link: LINKS.LOMAS },
}

const TXT_ESTUDIOS = `üßæ Estudios i-R Dental:
‚Ä¢ Panor√°mica (OPG)
‚Ä¢ Cefalom√©trica (lateral/PA)
‚Ä¢ Periapicales
‚Ä¢ Oclusales
‚Ä¢ Serie completa
‚Ä¢ ATM b√°sica
‚Ä¢ CBCT / Tomograf√≠a (si corresponde)
‚Ä¢ Fotograf√≠as intra/extraorales (si corresponde)

‚úÖ SIN TURNO, por orden de llegada.`

const TXT_OBRAS = `üí≥ Obras sociales activas:
AMFFA, ANSSAL APDIS, APESA SALUD, CENTRO MEDICO PUEYRREDON, COLEGIO DE FARMAC√âUTICOS, DASMI, DASUTeN, FEDERADA, GALENO*, IOMA*, IOSFA, MEDICUS*, OMINT*, OSDE*, OSECAC, OSPACA, OSPE, OSPERYHRA, PAMI, PREMEDIC, SIMECO, SWISS MEDICAL*.
(*) Algunas con requisitos de orden/diagn√≥stico.
‚ö†Ô∏è Este listado puede cambiar. Consult√° por WhatsApp, tel√©fono o mail.`

// --- Men√∫s (como tu versi√≥n anterior) ---
async function sendMainMenuButtons(toRawDigits, storeKey) {
  await sendButtons(toRawDigits, 'Men√∫ (1/2): eleg√≠ una opci√≥n', [
    { id:'MENU_SEDES',    title:'üìç Sedes' },
    { id:'MENU_ESTUDIOS', title:'üßæ Estudios' },
    { id:'MENU_OBRAS',    title:'üí≥ Obras sociales' },
  ], storeKey)
  await sendButtons(toRawDigits, 'Men√∫ (2/2): m√°s opciones', [
    { id:'MENU_ENVIO',       title:'üì§ Env√≠o de estudio' },
    { id:'MENU_SUBIR_ORDEN', title:'üìé Subir orden' },
    { id:'MENU_OPERADOR',    title:'üë§ Operador' },
  ], storeKey)
}

async function sendSedesButtons(toRawDigits, storeKey) {
  return sendButtons(toRawDigits, 'Eleg√≠ una sede para ver direcci√≥n y contacto:', [
    { id:'SEDE_QUILMES', title:'Quilmes' },
    { id:'SEDE_AVELL',   title:'Avellaneda' },
    { id:'SEDE_LOMAS',   title:'Lomas' },
  ], storeKey)
}

function sedeInfo(key) {
  const s = SEDES[key]
  return `üìç ${s.title}
Direcci√≥n: ${s.dir}
Tel√©fono: ${s.tel}
Email: ${s.mail}
C√≥mo llegar: ${s.link}

${HOURS}

${NO_TURNO}`
}

// --- Validaciones (como tu versi√≥n) ---
function isValidDni(s) { return /^[0-9]{6,9}$/.test((s||'').replace(/\D/g,'')) }
function normalizeDate(s) {
  const t = (s||'').trim()
  const ddmmyyyy = /^([0-3]?\d)\/([01]?\d)\/(\d{4})$/
  const yyyymmdd = /^(\d{4})-(\d{2})-(\d{2})$/
  if (ddmmyyyy.test(t)) {
    const [, d, m, y] = t.match(ddmmyyyy)
    return `${y}-${String(m).padStart(2,'0')}-${String(d).padStart(2,'0')}`
  }
  if (yyyymmdd.test(t)) return t
  return null
}

// --- Flujo "Env√≠o de estudio" (calcado de tu anterior) ---
async function flowStart(fromKey) {
  await setSession(fromKey, { state:'envio_estudio', step:'APELLIDO', data:{
    apellido:'', nombre:'', dni:'', fechaNac:'', estudio:'', sede:'', via:'', email:''
  }, startedAt: Date.now() })
}
async function flowEnd(fromKey) {
  await setSession(fromKey, { state:'idle', step:0 })
}

async function promptNext(waRaw, waKey) {
  const s = await getSession(waKey)
  if (!s || s.state !== 'envio_estudio') return
  switch (s.step) {
    case 'APELLIDO':     await sendText(waRaw, '‚úçÔ∏è Ingres√° el **apellido** del paciente:', waKey); break
    case 'NOMBRE':       await sendText(waRaw, 'Ahora ingres√° el **nombre** del paciente:', waKey); break
    case 'DNI':          await sendText(waRaw, 'Ingres√° el **DNI** (solo n√∫meros):', waKey); break
    case 'FECHA_NAC':    await sendText(waRaw, 'Ingres√° la **fecha de nacimiento** (DD/MM/AAAA o AAAA-MM-DD):', waKey); break
    case 'ESTUDIO':      await sendText(waRaw, '¬øQu√© **estudio** se realiz√≥? (ej.: Panor√°mica OPG)', waKey); break
    case 'SEDE':         await sendButtons(waRaw, 'Eleg√≠ la **sede** donde se realiz√≥:', [
                          { id:'EV_SEDE_QUILMES', title:'Quilmes' },
                          { id:'EV_SEDE_AVELL',   title:'Avellaneda' },
                          { id:'EV_SEDE_LOMAS',   title:'Lomas' },
                         ], waKey); break
    case 'VIA':          await sendButtons(waRaw, '¬øPor d√≥nde quer√©s recibirlo?', [
                          { id:'EV_VIA_WSP',   title:'WhatsApp' },
                          { id:'EV_VIA_EMAIL', title:'Email' },
                         ], waKey); break
    case 'EMAIL_IF_NEEDED':
                          await sendText(waRaw, 'Indic√° tu **correo electr√≥nico**:', waKey); break
    case 'CONFIRM': {
      const d = s.data
      await sendButtons(waRaw,
        `Confirm√° los datos:\n‚Ä¢ Paciente: ${d.apellido}, ${d.nombre}\n‚Ä¢ DNI: ${d.dni}\n‚Ä¢ Nac.: ${d.fechaNac}\n‚Ä¢ Estudio: ${d.estudio}\n‚Ä¢ Sede: ${d.sede}\n‚Ä¢ V√≠a: ${d.via}${d.email ? ` (${d.email})` : ''}`,
        [{ id:'EV_CONFIRM_YES', title:'‚úÖ Confirmar' }, { id:'EV_CONFIRM_NO', title:'‚ùå Cancelar' }], waKey)
      break
    }
    default:
      await flowEnd(waKey)
      await sendText(waRaw, 'Listo. Si necesit√°s enviar un estudio, escrib√≠: Env√≠o de estudio', waKey)
  }
}

async function handleEnvioText(waRaw, waKey, rawBody) {
  const s = await getSession(waKey)
  if (!s || s.state !== 'envio_estudio') return false

  const body = (rawBody || '').trim()
  if (/^(cancelar|salir|menu|men√∫)$/i.test(body)) {
    await flowEnd(waKey)
    await sendText(waRaw, 'Se cancel√≥ la solicitud. Te dejo el men√∫:', waKey)
    await sendMainMenuButtons(waRaw, waKey)
    return true
  }

  switch (s.step) {
    case 'APELLIDO':
      s.data.apellido = body.toUpperCase()
      s.step = 'NOMBRE'
      await setSession(waKey, s); await promptNext(waRaw, waKey); return true
    case 'NOMBRE':
      s.data.nombre = body.toUpperCase()
      s.step = 'DNI'
      await setSession(waKey, s); await promptNext(waRaw, waKey); return true
    case 'DNI': {
      const digits = body.replace(/\D/g,'')
      if (!isValidDni(digits)) { await sendText(waRaw, 'El DNI no parece v√°lido. Escribilo solo con n√∫meros (6 a 9 d√≠gitos).', waKey); return true }
      s.data.dni = digits
      s.step = 'FECHA_NAC'
      await setSession(waKey, s); await promptNext(waRaw, waKey); return true
    }
    case 'FECHA_NAC': {
      const norm = normalizeDate(body)
      if (!norm) { await sendText(waRaw, 'Formato no v√°lido. Us√° DD/MM/AAAA o AAAA-MM-DD.', waKey); return true }
      s.data.fechaNac = norm
      s.step = 'ESTUDIO'
      await setSession(waKey, s); await promptNext(waRaw, waKey); return true
    }
    case 'ESTUDIO':
      s.data.estudio = body
      s.step = 'SEDE'
      await setSession(waKey, s); await promptNext(waRaw, waKey); return true
    case 'EMAIL_IF_NEEDED': {
      const ok = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(body)
      if (!ok) { await sendText(waRaw, 'Email no v√°lido. Prob√° nuevamente.', waKey); return true }
      s.data.email = body
      s.step = 'CONFIRM'
      await setSession(waKey, s); await promptNext(waRaw, waKey); return true
    }
  }
  return false
}

async function handleEnvioButton(waRaw, waKey, btnId) {
  const s = await getSession(waKey)
  if (!s || s.state !== 'envio_estudio') return false

  switch (s.step) {
    case 'SEDE':
      if (btnId === 'EV_SEDE_QUILMES' || btnId === 'EV_SEDE_AVELL' || btnId === 'EV_SEDE_LOMAS') {
        s.data.sede = btnId.replace('EV_SEDE_','').toLowerCase()
        s.step = 'VIA'
        await setSession(waKey, s); await promptNext(waRaw, waKey); return true
      }
      await sendText(waRaw, 'Eleg√≠ una opci√≥n de los botones, por favor.', waKey); return true

    case 'VIA':
      if (btnId === 'EV_VIA_WSP') { s.data.via = 'WhatsApp'; s.step = 'CONFIRM'; await setSession(waKey, s); await promptNext(waRaw, waKey); return true }
      if (btnId === 'EV_VIA_EMAIL'){ s.data.via = 'Email';    s.step = 'EMAIL_IF_NEEDED'; await setSession(waKey, s); await promptNext(waRaw, waKey); return true }
      await sendText(waRaw, 'Eleg√≠ una opci√≥n de los botones, por favor.', waKey); return true

    case 'CONFIRM':
      if (btnId === 'EV_CONFIRM_YES') {
        await sendText(waRaw, '‚úÖ Recibimos tu solicitud. Un/a operador/a la gestionar√° a la brevedad.', waKey)
        await flowEnd(waKey)
        await sendButtons(waRaw, '¬øQuer√©s volver al men√∫ o hablar con un operador?', [
          { id:'BTN_BACK_MENU', title:'‚Ü©Ô∏è Men√∫' },
          { id:'MENU_OPERADOR', title:'üë§ Operador' },
        ], waKey)
        return true
      }
      if (btnId === 'EV_CONFIRM_NO') {
        await flowEnd(waKey)
        await sendText(waRaw, 'Solicitud cancelada. Te dejo el men√∫:', waKey)
        await sendMainMenuButtons(waRaw, waKey)
        return true
      }
      await sendText(waRaw, 'Eleg√≠ una opci√≥n de los botones, por favor.', waKey); return true
  }
  return false
}

// --- Router de men√∫s (como el anterior) ---
async function routeMenuSelection(waRaw, waKey, selId) {
  switch (selId) {
    case 'BTN_BACK_MENU':
      await sendMainMenuButtons(waRaw, waKey); return true

    case 'MENU_SEDES':
      await sendSedesButtons(waRaw, waKey); return true
    case 'SEDE_QUILMES':
      await sendText(waRaw, sedeInfo('QUILMES'), waKey); return true
    case 'SEDE_AVELL':
      await sendText(waRaw, sedeInfo('AVELL'), waKey); return true
    case 'SEDE_LOMAS':
      await sendText(waRaw, sedeInfo('LOMAS'), waKey); return true

    case 'MENU_ESTUDIOS':
      await sendText(waRaw, TXT_ESTUDIOS, waKey); return true

    case 'MENU_OBRAS':
      await sendText(waRaw, TXT_OBRAS, waKey); return true

    case 'MENU_SUBIR_ORDEN':
      await sendText(waRaw,
        'üìé Para subir tu orden, adjunt√° una foto clara de la orden m√©dica.\n' +
        'Un/a operador/a te responder√° con la confirmaci√≥n.', waKey)
      return true

    case 'MENU_OPERADOR':
      await sendText(waRaw, 'üë§ Derivando a operador. Te responder√°n a la brevedad.', waKey); return true

    case 'MENU_ENVIO': // iniciar flujo
      flowLog('START', { wa: waKey })
      await flowStart(waKey)
      await sendText(waRaw, 'Vamos a tomar los datos para enviar tu estudio. Pod√©s escribir **cancelar** en cualquier momento.', waKey)
      await promptNext(waRaw, waKey)
      return true
  }
  return false
}

// --- Bienvenida SIEMPRE ---
async function sendWelcome(waRaw, waKey) {
  await sendText(waRaw, '¬°Hola! üëã Soy el asistente de i-R Dental.', waKey)
  await sendMainMenuButtons(waRaw, waKey)
}

// --- Router principal ---
async function routeIncomingMessage(waRaw, waKey, kind, payloadTextOrId) {
  // Bienvenida SIEMPRE antes de nada si est√° idle y no es comando directo del flujo
  const sess = await getSession(waKey)
  if (!sess || sess.state === 'idle') {
    // Si llega un bot√≥n/lista, proseguimos; si llega texto que no es ‚Äúenv√≠o de estudio‚Äù, damos bienvenida
    if (kind === 'text') {
      const t = (payloadTextOrId || '').trim().toLowerCase()
      const isCmd = /(envio|env√≠o) de estudio|^1$/.test(t)
      if (!isCmd) { await sendWelcome(waRaw, waKey); return }
    }
  }

  if (kind === 'interactive') {
    const sel = payloadTextOrId || ''
    flowLog('BTN_STEP', { wa: waKey, sel })
    // Primero, si hay flujo activo, dejalo consumir
    if (await handleEnvioButton(waRaw, waKey, sel)) return
    // Si no lo consumi√≥, es un men√∫
    if (await routeMenuSelection(waRaw, waKey, sel)) return
    await sendMainMenuButtons(waRaw, waKey); return
  }

  if (kind === 'text') {
    const text = payloadTextOrId || ''
    flowLog('TEXT_STEP', { wa: waKey, text })
    // Flujo activo primero
    if (await handleEnvioText(waRaw, waKey, text)) return

    // Comando directo ‚ÄúEnv√≠o de estudio‚Äù
    if (/(envio|env√≠o) de estudio|^1$/.test((text||'').toLowerCase())) {
      await routeMenuSelection(waRaw, waKey, 'MENU_ENVIO'); return
    }

    // Cualquier otra cosa ‚Üí recordatorio men√∫
    await sendText(waRaw, 'Para iniciar, toc√° un bot√≥n del men√∫ o escrib√≠: Env√≠o de estudio.', waKey)
    await sendMainMenuButtons(waRaw, waKey)
    return
  }
}

// --- Handler HTTP ---
export default async function handler(req, res) {
  // GET: verificaci√≥n Meta o feed operador
  if (req.method === 'GET') {
    const mode = req.query['hub.mode']
    const token = req.query['hub.verify_token']
    const challenge = req.query['hub.challenge']
    if (mode === 'subscribe') {
      if (token === WSP_VERIFY_TOKEN) return res.status(200).send(challenge)
      return res.status(403).send('Forbidden')
    }

    const { secret, wa, limit = '100' } = req.query || {}
    if (secret !== OPERATOR_SECRET) return res.status(401).json({ error:'unauthorized' })

    if (wa) {
      const history = await getHistory(wa, parseInt(limit,10) || 100)
      return res.status(200).json({ wa, messages: history })
    }

    // Lista de chats recientes (desc)
    const rows = await redis.zrange(kChats, 0, 49, { rev:true, withScores:true })
    let items
    if (Array.isArray(rows) && rows.length && typeof rows[0] === 'object') {
      items = rows.map(r => ({ wa:r.member, ts:Number(r.score) }))
    } else {
      items = []; for (let i=0;i<rows.length;i+=2) items.push({ wa:rows[i], ts:Number(rows[i+1]) })
    }
    return res.status(200).json({ chats: items })
  }

  // POST: WhatsApp webhook events o env√≠o de operador
  if (req.method === 'POST') {
    const { raw, json } = await readBody(req)

    // Rama operador
    if (json?.op === 'send') {
      const { secret, wa, text } = json || {}
      if (secret !== OPERATOR_SECRET) return res.status(401).json({ error:'unauthorized' })
      if (!wa || !text) return res.status(400).json({ error:'wa and text required' })
      let waRaw = await redis.get(kWaRaw(wa))
      if (!waRaw) waRaw = wa.replace(/^\+/, '') // fallback b√°sico
      const r = await sendText(waRaw, text, wa)
      return res.status(r.ok ? 200 : 500).json(r)
    }

    // Rama Meta webhook
    flowLog('WEBHOOK_BODY', raw)
    const entry  = json?.entry?.[0]
    const change = entry?.changes?.[0]
    const value  = change?.value
    if (!value) return res.status(200).json({ ok:true })

    if (Array.isArray(value.statuses) && value.statuses.length) {
      flowLog('STATUSES', value.statuses); return res.status(200).json({ ok:true })
    }

    const waIdRaw = value?.contacts?.[0]?.wa_id            // 54911... o 5411...
    const waKey   = normalizeWaKey(waIdRaw)                 // +5411..., sin 9 si corresponde
    const msg     = value?.messages?.[0]
    if (!waKey || !msg) { flowLog('MISSING_MSG', { wa:waIdRaw, hasMsg:!!msg }); return res.status(200).json({ ok:true }) }

    // Guardar √∫ltimo wa_id crudo para operador
    if (waIdRaw) await redis.set(kWaRaw(waKey), waIdRaw)

    // Idempotencia
    if (await alreadyProcessed(waKey, msg.id)) { flowLog('DUPLICATE', { wa:waKey, id:msg.id }); return res.status(200).json({ ok:true }) }

    const type = msg.type
    const ts   = Number(msg.timestamp ? Number(msg.timestamp) * 1000 : Date.now())

    // Persistencia consola (IN)
    if (type === 'text') {
      const bodyIn = msg.text?.body || ''
      await appendMessage(waKey, { id:msg.id, from:waKey, direction:'in', text: bodyIn, ts })
      await routeIncomingMessage(waIdRaw, waKey, 'text', bodyIn)
      return res.status(200).json({ ok:true })
    }

    if (type === 'interactive') {
      const selId = msg?.interactive?.button_reply?.id || msg?.interactive?.list_reply?.id || ''
      await appendMessage(waKey, { id:msg.id, from:waKey, direction:'in', text: selId, ts, type:'interactive', meta: msg.interactive })
      // Primero deja consumir al flujo activo (sede/v√≠a/confirm)
      if (await handleEnvioButton(waIdRaw, waKey, selId)) return res.status(200).json({ ok:true })
      // Sino, rutea como men√∫
      await routeIncomingMessage(waIdRaw, waKey, 'interactive', selId)
      return res.status(200).json({ ok:true })
    }

    // Otros tipos (documento, imagen, etc.) ‚Üí s√≥lo log + guardado b√°sico
    await appendMessage(waKey, { id:msg.id, from:waKey, direction:'in', text:`[${type}]`, ts })
    await sendText(waIdRaw, 'Recibimos tu mensaje. Para empezar, toc√° un bot√≥n del men√∫ o escrib√≠: Env√≠o de estudio.', waKey)
    await sendMainMenuButtons(waIdRaw, waKey)
    return res.status(200).json({ ok:true })
  }

  res.setHeader('Allow', ['GET','POST'])
  return res.status(405).send('Method Not Allowed')
}
